package com.gameaccountshop.repository;

import com.gameaccountshop.entity.GameAccount;
import com.gameaccountshop.enums.AccountStatus;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.jdbc.AutoConfigureTestDatabase;
import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;
import org.springframework.boot.test.autoconfigure.orm.jpa.TestEntityManager;
import org.springframework.test.context.TestPropertySource;

import java.math.BigDecimal;
import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;

/**
 * Test class for GameAccountRepository - Data Access Layer
 *
 * Tests verify:
 * - Entity is saved with correct default values
 * - findBySellerId returns correct listings
 * - findByStatus returns filtered listings
 * - Status defaults to PENDING
 * - Timestamps are generated
 */
@DataJpaTest
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
@TestPropertySource(properties = {
    "spring.datasource.url=jdbc:h2:mem:testdb;MODE=MySQL;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE",
    "spring.datasource.driver-class-name=org.h2.Driver",
    "spring.jpa.database-platform=org.hibernate.dialect.H2Dialect",
    "spring.jpa.hibernate.ddl-auto=create-drop",
    "spring.flyway.enabled=false"
})
class GameAccountRepositoryTest {

    @Autowired
    private GameAccountRepository repository;

    @Autowired
    private TestEntityManager entityManager;

    private GameAccount testListing;

    @BeforeEach
    void setUp() {
        // Create test listing
        testListing = new GameAccount();
        testListing.setSellerId(1L);
        testListing.setGameName("Liên Minh Huyền Thoại");
        testListing.setRank("Diamond");
        testListing.setPrice(new BigDecimal("500000"));
        testListing.setDescription("Tài khoản có nhiều skin quý giá");
    }

    /**
     * AC #6: Verify default status is PENDING when saving new listing
     */
    @Test
    void testSaveListingDefaultsToPendingStatus() {
        // When: Save listing without explicitly setting status
        GameAccount saved = repository.save(testListing);

        // Then: Status defaults to PENDING
        assertThat(saved.getStatus()).isEqualTo(AccountStatus.PENDING);
        assertThat(saved.getId()).isNotNull();
    }

    /**
     * Verify createdAt timestamp is auto-generated by @PrePersist
     */
    @Test
    void testSaveListingGeneratesCreatedAtTimestamp() {
        // When: Save listing
        GameAccount saved = repository.save(testListing);

        // Then: createdAt is automatically set
        assertThat(saved.getCreatedAt()).isNotNull();
    }

    /**
     * Verify findBySellerId returns all listings for a specific seller
     */
    @Test
    void testFindBySellerId() {
        // Given: Save listings for different sellers
        GameAccount listing1 = new GameAccount();
        listing1.setSellerId(1L);
        listing1.setGameName("Game A");
        listing1.setRank("Rank A");
        listing1.setPrice(new BigDecimal("100000"));
        listing1.setDescription("Description A");
        listing1.setStatus(AccountStatus.PENDING);
        repository.save(listing1);

        GameAccount listing2 = new GameAccount();
        listing2.setSellerId(1L);
        listing2.setGameName("Game B");
        listing2.setRank("Rank B");
        listing2.setPrice(new BigDecimal("200000"));
        listing2.setDescription("Description B");
        listing2.setStatus(AccountStatus.APPROVED);
        repository.save(listing2);

        GameAccount otherSellerListing = new GameAccount();
        otherSellerListing.setSellerId(2L);
        otherSellerListing.setGameName("Game C");
        otherSellerListing.setRank("Rank C");
        otherSellerListing.setPrice(new BigDecimal("300000"));
        otherSellerListing.setDescription("Description C");
        otherSellerListing.setStatus(AccountStatus.PENDING);
        repository.save(otherSellerListing);

        // When: Query for seller 1's listings
        List<GameAccount> seller1Listings = repository.findBySellerId(1L);

        // Then: Only seller 1's listings are returned
        assertThat(seller1Listings).hasSize(2);
        assertThat(seller1Listings)
            .allMatch(listing -> listing.getSellerId().equals(1L));
        assertThat(seller1Listings)
            .anyMatch(listing -> listing.getGameName().equals("Game A"));
        assertThat(seller1Listings)
            .anyMatch(listing -> listing.getGameName().equals("Game B"));
    }

    /**
     * Verify findByStatus returns listings filtered by status
     */
    @Test
    void testFindByStatus() {
        // Given: Save listings with different statuses
        GameAccount pending1 = new GameAccount();
        pending1.setSellerId(1L);
        pending1.setGameName("Game A");
        pending1.setRank("Rank A");
        pending1.setPrice(new BigDecimal("100000"));
        pending1.setDescription("Description A");
        pending1.setStatus(AccountStatus.PENDING);
        repository.save(pending1);

        GameAccount pending2 = new GameAccount();
        pending2.setSellerId(2L);
        pending2.setGameName("Game B");
        pending2.setRank("Rank B");
        pending2.setPrice(new BigDecimal("200000"));
        pending2.setDescription("Description B");
        pending2.setStatus(AccountStatus.PENDING);
        repository.save(pending2);

        GameAccount approved = new GameAccount();
        approved.setSellerId(1L);
        approved.setGameName("Game C");
        approved.setRank("Rank C");
        approved.setPrice(new BigDecimal("300000"));
        approved.setDescription("Description C");
        approved.setStatus(AccountStatus.APPROVED);
        repository.save(approved);

        GameAccount sold = new GameAccount();
        sold.setSellerId(2L);
        sold.setGameName("Game D");
        sold.setRank("Rank D");
        sold.setPrice(new BigDecimal("400000"));
        sold.setDescription("Description D");
        sold.setStatus(AccountStatus.SOLD);
        repository.save(sold);

        // When: Query for PENDING listings
        List<GameAccount> pendingListings = repository.findByStatus(AccountStatus.PENDING);

        // Then: Only PENDING listings are returned
        assertThat(pendingListings).hasSize(2);
        assertThat(pendingListings)
            .allMatch(listing -> listing.getStatus() == AccountStatus.PENDING);

        // When: Query for APPROVED listings
        List<GameAccount> approvedListings = repository.findByStatus(AccountStatus.APPROVED);

        // Then: Only APPROVED listings are returned
        assertThat(approvedListings).hasSize(1);
        assertThat(approvedListings.get(0).getGameName()).isEqualTo("Game C");

        // When: Query for SOLD listings
        List<GameAccount> soldListings = repository.findByStatus(AccountStatus.SOLD);

        // Then: Only SOLD listings are returned
        assertThat(soldListings).hasSize(1);
        assertThat(soldListings.get(0).getGameName()).isEqualTo("Game D");
    }

    /**
     * Verify findByStatusAndRank filters by both status and rank
     */
    @Test
    void testFindByStatusAndRank() {
        // Given: Save listings with different statuses and ranks
        GameAccount diamondPending = new GameAccount();
        diamondPending.setSellerId(1L);
        diamondPending.setGameName("LOL");
        diamondPending.setRank("Diamond");
        diamondPending.setPrice(new BigDecimal("500000"));
        diamondPending.setDescription("Diamond account");
        diamondPending.setStatus(AccountStatus.PENDING);
        repository.save(diamondPending);

        GameAccount goldPending = new GameAccount();
        goldPending.setSellerId(1L);
        goldPending.setGameName("LOL");
        goldPending.setRank("Gold");
        goldPending.setPrice(new BigDecimal("200000"));
        goldPending.setDescription("Gold account");
        goldPending.setStatus(AccountStatus.PENDING);
        repository.save(goldPending);

        GameAccount diamondApproved = new GameAccount();
        diamondApproved.setSellerId(2L);
        diamondApproved.setGameName("LOL");
        diamondApproved.setRank("Diamond");
        diamondApproved.setPrice(new BigDecimal("600000"));
        diamondApproved.setDescription("Diamond approved");
        diamondApproved.setStatus(AccountStatus.APPROVED);
        repository.save(diamondApproved);

        // When: Query for PENDING + Diamond
        List<GameAccount> pendingDiamond = repository.findByStatusAndRank(AccountStatus.PENDING, "Diamond");

        // Then: Only PENDING Diamond listings returned
        assertThat(pendingDiamond).hasSize(1);
        assertThat(pendingDiamond.get(0).getRank()).isEqualTo("Diamond");
        assertThat(pendingDiamond.get(0).getStatus()).isEqualTo(AccountStatus.PENDING);

        // When: Query for PENDING + Gold
        List<GameAccount> pendingGold = repository.findByStatusAndRank(AccountStatus.PENDING, "Gold");

        // Then: Only PENDING Gold listings returned
        assertThat(pendingGold).hasSize(1);
        assertThat(pendingGold.get(0).getRank()).isEqualTo("Gold");

        // When: Query for APPROVED + Diamond
        List<GameAccount> approvedDiamond = repository.findByStatusAndRank(AccountStatus.APPROVED, "Diamond");

        // Then: Only APPROVED Diamond listings returned
        assertThat(approvedDiamond).hasSize(1);
        assertThat(approvedDiamond.get(0).getStatus()).isEqualTo(AccountStatus.APPROVED);
    }

    /**
     * Verify findApprovedByGameName searches game names case-insensitively
     */
    @Test
    void testFindApprovedByGameName() {
        // Given: Save APPROVED listings with different game names
        GameAccount lol1 = new GameAccount();
        lol1.setSellerId(1L);
        lol1.setGameName("Liên Minh Huyền Thoại");
        lol1.setRank("Diamond");
        lol1.setPrice(new BigDecimal("500000"));
        lol1.setDescription("LOL Diamond");
        lol1.setStatus(AccountStatus.APPROVED);
        repository.save(lol1);

        GameAccount valorant = new GameAccount();
        valorant.setSellerId(2L);
        valorant.setGameName("Valorant");
        valorant.setRank("Immortal");
        valorant.setPrice(new BigDecimal("1000000"));
        valorant.setDescription("Valorant Immortal");
        valorant.setStatus(AccountStatus.APPROVED);
        repository.save(valorant);

        GameAccount lol2 = new GameAccount();
        lol2.setSellerId(3L);
        lol2.setGameName("Liên Minh Huyền Thoại 2"); // Same base name with suffix
        lol2.setRank("Challenger");
        lol2.setPrice(new BigDecimal("2000000"));
        lol2.setDescription("LOL Challenger");
        lol2.setStatus(AccountStatus.APPROVED);
        repository.save(lol2);

        GameAccount pendingLol = new GameAccount();
        pendingLol.setSellerId(4L);
        pendingLol.setGameName("Liên Minh Huyền Thoại");
        pendingLol.setRank("Gold");
        pendingLol.setPrice(new BigDecimal("300000"));
        pendingLol.setDescription("LOL Gold - PENDING");
        pendingLol.setStatus(AccountStatus.PENDING);
        repository.save(pendingLol);

        // When: Search for "Huyền" (partial match, case-insensitive)
        List<GameAccount> results = repository.findApprovedByGameName("Huyền", AccountStatus.APPROVED);

        // Then: Only APPROVED listings with matching game name returned
        assertThat(results).hasSize(2);
        assertThat(results)
            .allMatch(listing -> listing.getStatus() == AccountStatus.APPROVED);
        assertThat(results)
            .allMatch(listing -> listing.getGameName().contains("Huyền"));

        // PENDING listing should NOT be included
        assertThat(results)
            .noneMatch(listing -> listing.getId().equals(pendingLol.getId()));
    }

    /**
     * Verify BigDecimal price is stored with correct precision
     */
    @Test
    void testPriceStoredWithCorrectPrecision() {
        // Given: Listing with decimal price
        testListing.setPrice(new BigDecimal("999999.99"));

        // When: Save listing
        GameAccount saved = repository.save(testListing);
        entityManager.flush();
        entityManager.clear();

        // When: Reload from database
        GameAccount reloaded = repository.findById(saved.getId()).orElseThrow();

        // Then: Price is preserved with correct precision
        assertThat(reloaded.getPrice()).isEqualByComparingTo("999999.99");
    }
}
